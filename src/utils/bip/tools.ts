import * as ed from "@noble/ed25519";
import { sha256 } from "@noble/hashes/sha256";
import { sha512 } from "@noble/hashes/sha512";
import {
  entropyToMnemonic,
  mnemonicToSeedSync,
  validateMnemonic,
  wordlists,
} from "bip39";
import CryptoJS from "crypto-js";
import { Language, mnemonicWordLists } from "./basic";

/** BEGIN polyfill */
ed.etc.sha512Sync = (...m) => sha512(ed.etc.concatBytes(...m));
// eslint-disable-next-line @typescript-eslint/no-var-requires
global.Buffer = require("buffer").Buffer;
/** END polyfill */

const DEFAULT_LANG: Language = "chinese_simplified";

/**
 * Used in UserAddView, to check if the user input a valid mnemonic sentence.
 * A valid mnemonic sentence is concatenated by 12 mnemonics in the word list,
 * and the corresponded entropy has valid checksum (the last 4 bits in our case).
 *
 * @example "的 的 的 的 的 的 的 的 的 的 的 在" -> true
 *          "铝 北 肠 泼 舞 京 墙 色 谐 养 园 暗" -> true
 *          "的 的 的 的 的 的 的 的 的 的 的 的" -> false
 *          "的 的 的 的 的 的 的 的 的 的 的" -> false
 */
export function isValidMnemonics(
  sentence: string,
  lang: Language = DEFAULT_LANG
): boolean {
  const userWordList = normalize(sentence).split(" ");
  if (userWordList.length !== 12) {
    return false;
  }
  return validateMnemonic(sentence, mnemonicWordLists[lang]);
}

/**
 * For a mnemonic sentence with insufficient length, this function generates
 * random bits to pad its entropy, and derive the checksum, finally returns the
 * standard (valid) mnemonic sentence.
 *
 * @param ENT @see https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki
 */
export function fixMnemonics(
  sentence: string,
  lang: Language = DEFAULT_LANG,
  ENT: 128 | 160 | 192 | 224 | 256 = 128
): string {
  const wordList = wordlists[lang];
  const userWordList = normalize(sentence).split(" ");
  const CS = ENT / 32;
  const MS = (ENT + CS) / 11;
  if (userWordList.length > MS) {
    throw new Error("The given sentence is too long!");
  }
  if (userWordList.length === MS) {
    if (validateMnemonic(sentence, mnemonicWordLists[lang])) return sentence;
    throw new Error("The given sentence is invalid, and can't be fixed!");
  }
  // assert(userWordList.length < MS)
  const bits = userWordList
    .map((word) => {
      const index = wordList.indexOf(word);
      if (index === -1) {
        throw new Error();
      }
      return padString(index.toString(2), "0", 11);
    })
    .join("");
  // assert(bits.length === userWordList.length * 11)
  const entropyBits =
    bits +
    Array(ENT - bits.length)
      .fill("")
      .map(() => Math.floor(Math.random() * 2).toString(2))
      .join("");

  const entropyBytes = (entropyBits.match(/(.{1,8})/g) as RegExpMatchArray).map(
    binaryToByte
  );
  const entropy = Buffer.from(entropyBytes);
  const checksum = deriveChecksumBits(entropy);
  const finalEntropy =
    entropy.toString("hex") + binaryToByte(checksum).toString(16);

  return entropyToMnemonic(finalEntropy, wordList);
}

interface HandleResult {
  privateKey: string;
  publicKey: string;
  /**
   * @param message raw string
   */
  sign: (message: string) => Uint8Array;
  /**
   * @param signature Uint8Array
   * @param message the expected message, raw string
   */
  verify: (signature: Uint8Array, message: string) => boolean;
}

/**
 * This function handles a mnemonic sentence, returns useful information
 * (all in hex).
 * @attention this function never check if the mnemonic sentence is valid.
 *
 * @returns mnemonics: original input
 * @returns valid: boolean
 * @returns privateKey, publicKey: derived key pair.
 *          the private key is derived by bip44 standard,
 *          the public key is generated by the private key with ed25519.
 * @returns sign, verify: callbacks to sign (with private key) or verify (with public key)
 */
export function handleMnemonics(sentence: string): HandleResult {
  const masterKeys = mnemonicToKeys(sentence);
  // bip44 standard
  const { key } = deriveKeys(masterKeys, "m/44'/0'/0'/0/0");
  const privateKey = Buffer.from(key);
  const publicKey = ed.getPublicKey(privateKey);

  return {
    privateKey: privateKey.toString("hex"),
    publicKey: Buffer.from(publicKey).toString("hex"),
    sign(message) {
      const buffer = Buffer.from(normalize(message), "utf-8");
      return ed.sign(buffer, privateKey);
    },
    verify(signature, message) {
      const buffer = Buffer.from(normalize(message), "utf-8");
      return ed.verify(signature, buffer, publicKey);
    },
  };
}

/**
 * This function handles the final private key (skips the steps of deriving keys from mnemonics)
 * @param privateKey hex
 * @returns @see handleMnemonics
 */
export function handlePrivateKey(privateKey: string): HandleResult {
  const publicKey = ed.getPublicKey(privateKey);

  return {
    privateKey: privateKey,
    publicKey: Buffer.from(publicKey).toString("hex"),
    sign(message) {
      const buffer = Buffer.from(normalize(message), "utf-8");
      return ed.sign(buffer, Buffer.from(privateKey, "hex"));
    },
    verify(signature, message) {
      const buffer = Buffer.from(normalize(message), "utf-8");
      return ed.verify(signature, buffer, publicKey);
    },
  };
}

/**
 * This function uses private key to sign a raw string (with ED25519),
 * and encode the signature with base64.
 * @param message raw string
 * @param privateKey hex
 * @returns signature encoded by base64
 */
export function signAndEncode(message: string, privateKey: string): string {
  const signature = ed.sign(
    Buffer.from(normalize(message)),
    Buffer.from(privateKey, "hex")
  );
  return Buffer.from(signature).toString("base64");
}

function normalize(str: string) {
  return (str || "").normalize("NFKD");
}

function padString(str: string, plh: string, length: number) {
  if (plh.length !== 1) {
    throw new Error("The placeholder must have length of 1");
  }
  return plh.repeat(length - str.length) + str;
}

function binaryToByte(bin: string): number {
  return parseInt(bin, 2);
}

function bytesToBinary(bytes: number[]): string {
  return bytes.map((x) => padString(x.toString(2), "0", 8)).join("");
}

function deriveChecksumBits(entropyBuffer: Buffer) {
  const ENT = entropyBuffer.length * 8;
  const CS = ENT / 32;
  const hash = sha256(Uint8Array.from(entropyBuffer));

  return bytesToBinary(Array.from(hash)).slice(0, CS);
}

/**
 * @summary Native implements of HDKey
 * @author Yiyang Wu
 */
interface Keys {
  key: Buffer;
  chainCode: Buffer;
}

const offset = 0x80000000;
const replaceDerive = (s: string): string => {
  return s.replace("'", "");
};
const byteArrayToWordArray = (ba: Buffer) => {
  const wa: number[] = [];
  for (let i = 0; i < ba.length; i++) {
    wa[(i / 4) | 0] |= ba[i] << (24 - 8 * i);
  }
  return CryptoJS.lib.WordArray.create(wa, ba.length);
};
const wordToByteArray = (word: number, length: number): Buffer => {
  const bytes: Buffer = Buffer.alloc(length);
  if (length > 0) bytes.writeUint8(word >>> 24, 0);
  if (length > 1) bytes.writeUint8((word >>> 16) & 0xff, 1);
  if (length > 2) bytes.writeUint8((word >>> 8) & 0xff, 2);
  if (length > 3) bytes.writeUint8(word & 0xff, 3);
  return bytes;
};
const wordArrayToByteArray = (wordArray: CryptoJS.lib.WordArray): Buffer => {
  let result: Buffer = Buffer.alloc(0);
  let length: number = wordArray.sigBytes;
  let i = 0;
  while (length > 0) {
    const bytes = wordToByteArray(wordArray.words[i], Math.min(4, length));
    length -= bytes.length;
    result = Buffer.concat([result, bytes]);
    i++;
  }
  return result;
};
const CKDPriv = ({ key, chainCode }: Keys, index: number): Keys => {
  const indexBuffer = Buffer.allocUnsafe(4);
  indexBuffer.writeUInt32BE(index, 0);
  const data = Buffer.concat([Buffer.alloc(1, 0), key, indexBuffer]);
  const I = wordArrayToByteArray(
    CryptoJS.HmacSHA512(
      byteArrayToWordArray(data),
      byteArrayToWordArray(chainCode)
    )
  );
  const IL = I.subarray(0, 32);
  const IR = I.subarray(32, 64);
  return {
    key: IL,
    chainCode: IR,
  };
};
const deriveKeys = (keys: Keys, path: string): Keys => {
  const segments = path
    .split("/")
    .slice(1)
    .map(replaceDerive)
    .map((n) => parseInt(n, 10));
  return segments.reduce((priv, s) => CKDPriv(priv, s + offset), keys);
};
const mnemonicToKeys = (mnemonic: string): Keys => {
  const I = mnemonicToSeedSync(mnemonic);
  const IL = I.subarray(0, 32);
  const IR = I.subarray(32);
  return {
    key: IL,
    chainCode: IR,
  };
};
